#pragma config(Sensor, S1,     touchSensor,    sensorEV3_Touch)
#pragma config(Sensor, S2,     gyroSensor,     sensorEV3_Gyro, modeEV3Gyro_RateAndAngle)
#pragma config(Sensor, S3,     colorSensor,    sensorEV3_Color, modeEV3Color_Color)
#pragma config(Sensor, S4,     sonarSensor,    sensorEV3_Ultrasonic)
#pragma config(Motor,  motorA,           ,             tmotorEV3_Large, openLoop)
#pragma config(Motor,  motorB,          leftMotor,     tmotorEV3_Large, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorC,          rightMotor,    tmotorEV3_Large, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//


const float DEGREESTOCM = 360/17.5;

float distanceInDegrees(long distance)
	{

   	return distance*DEGREESTOCM;

	}

void drive (long nMotorRatio, long dist, long power)

	{

   	float degreesToTurn = 0;

    degreesToTurn = distanceInDegrees(dist);

    setMotorSyncEncoder(leftMotor,rightMotor,nMotorRatio,degreesToTurn,power);

    waitUntilMotorStop(leftMotor);

	}

void turn90(long nMotorRatio,long power)
	{

  	setMotorSyncEncoder(leftMotor, rightMotor, nMotorRatio,180,power);

    waitUntilMotorStop(leftMotor);

	}

task main()
{
      for(int i=0; i <1;i++)
      {

      drive(0,50,50);
      turn90(100,50);


      // display value of the encoder on screen
      displayCenteredBigTextLine(4, "Encoder: %d cm", (getMotorEncoder(motorB)/17.3) );

      // sync both motors and rotate them by 360 degrees at 50 power
      setMotorSyncEncoder(leftMotor, rightMotor, 0, 360, 50);

      // wait until motor to finish rotating
      //waitUntilMotorStop(motorB);

      sleep(3000);


			}

}
